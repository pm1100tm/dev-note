# 리스트 요소의 중복 제거에는 set 을 사용하자

여기 중복 값이 들어가 있는 정수 배열이 있습니다. 이 정수 배열에서 중복 값을 제거할 때는 망설임없이
set 을 사용하는 것이 코드 길이로도 가장 효율적일 것입니다.

```python
number_list = [1,2,3,4,5,5,6,7]
unique_number_list = list(set(number_list))
```

그렇다면 여기에 중복 되지 않은 값을 가진 정수 배열이 복수개 존재하되, 각 리스트의 원소들이 서로 중복되지
않도록 편집하기 위해서는 어떻게 해야 할까요? 아래와 같은 코드로 구현할 수 있습니다.

```python
a_list = [1,2,3,4,5]
b_list = [5,6,7,8,9]

unique_a_list = [v for v in a_list if v not in b_list]
unique_b_list = [v for v in b_list if v not in a_list]
```

이렇게 하면 각 리스트에 5라는 값이 제거되어, 서로 유니크한 값을 가진 배열이 됩니다.

그러나 이 경우, 리스트 컴프리헨션을 사용하여 중복을 제거하는 방식은, 각 요소에 대해 중복 여부를 확인해야
합니다. 이 과정에서 리스트 요소를 하나씩 비교하게 되며, 이는 시간 복잡도 측면에서 비효율적입니다.

위의 연산에서 사용되는 in 연산은 리스트의 길이가 m 일 때 O(m)의 시간 복잡도를 가집니다. 따라서,
a_list 와 b_list 의 모든 요소를 검사해야 하므로 전체 시간 복잡도는 O(n\*m)이 됩니다.

## set 을 사용한다면?

리스트 컴프리헨션을 사용하여 중복을 제거하는 것은 set 을 사용하여 차집합을 구하는 것보다 느립니다.
그 이유는 set은 해시 테이블 기반의 연산을 하기 때문입니다. 해시 테이블을 기반으로 하기 때문에
평균적으로 O(1) 시간 복잡도로 요소의 포함 여부를 검사하여 중복을 제거할 수 있습니다.

```python
a_list = [1,2,3,4,5]
b_list = [5,6,7,8,9]

a_set = set(a_list)
b_set = set(b_list)

a_list = list(a_set - b_set)
b_list = list(b_set - a_set)
```

위 코드에서 set의 차집합 연산은 O(n)의 시간 복잡도를 가집니다. 이는 리스트의 요소 수에 비례하며,
리스트 컴프리헨션보다 훨씬 더 효율적입니다.

따라서 대규모 데이터셋에서는 set을 사용한 방법이 훨씬 더 효율적입니다.
